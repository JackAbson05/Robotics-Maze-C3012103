{"mode":"Text","hardwareTarget":"brain","textContent":"#region VEXcode Generated Robot Configuration\nimport math\nimport random\nfrom vexcode_vr import *\n\n# Brain should be defined by default\nbrain=Brain()\n\ndrivetrain = Drivetrain(\"drivetrain\", 0)\npen = Pen(\"pen\", 8)\npen.set_pen_width(THIN)\nleft_bumper = Bumper(\"leftBumper\", 2)\nright_bumper = Bumper(\"rightBumper\", 3)\nfront_eye = EyeSensor(\"frontEye\", 4)\ndown_eye = EyeSensor(\"downEye\", 5)\nfront_distance = Distance(\"frontdistance\", 6)\ndistance = front_distance\nmagnet = Electromagnet(\"magnet\", 7)\nlocation = Location(\"location\", 9)\n\n#endregion VEXcode Generated Robot Configuration\nmyVariable = 0\n\ndef main():\n\n    drivetrain.set_drive_velocity(100, PERCENT)\n    drivetrain.set_turn_velocity(100, PERCENT)\n    drivetrain.set_heading(0, DEGREES)\n\n    pen.set_pen_color(BLACK)\n    pen.move(DOWN)\n\n# gets the starting point\n\n    row, col = get_cell()\n    Visited[row + Offset][col + Offset] = True\n    Path.append((row, col))\n\n    while not down_eye.detect(RED):\n\n        move()\n        wait(0.1, SECONDS)\n\n        # prints the coordinates of each move to the console\n        \n        row, col = get_cell()\n        brain.print(\"\\n\")\n        brain.print(row)\n        brain.print(\",\")\n        brain.print(col)\n\n    Start = Path[0]\n    End = Path[-1]\n\n    Shortest_Path = BFS(Start, End)\n# changes color to show the quickest route\n    pen.move(UP)\n    pen.set_pen_color(GREEN)\n    pen.move(DOWN)\n    \n    drivetrain.set_heading(0, DEGREES)\n\n    Follow_Path(Shortest_Path[::-1])\n\n\n\n\n\nStep_MM = 250\nGrid_Size = Step_MM\nSize = 64\nOffset = 15\nVisited = [[False for _ in range(Size)] for _ in range(Size)]\nPath = []\n\n# finds valid directions to move using distance infront\n\ndef get_distance():\n    # Front\n    forward_move = distance.get_distance(MM) > Step_MM\n\n    # Left\n    drivetrain.turn_for(LEFT, 90, DEGREES)\n    left_move = distance.get_distance(MM) > Step_MM\n\n    # Right\n    drivetrain.turn_for(LEFT, 180, DEGREES)\n    right_move = distance.get_distance(MM) > Step_MM\n\n    # Return to forward\n    drivetrain.turn_for(LEFT, 90, DEGREES)\n\n    return left_move, forward_move, right_move\n\n\n# chooses which direction to move favouring left \ndef move():\n    left_move, forward_move, right_move = get_distance()\n    # Left\n    if left_move:\n        drivetrain.turn_for(LEFT, 90, DEGREES)\n        drivetrain.drive_for(FORWARD, Step_MM, MM)\n    # Forward\n    elif forward_move:\n        drivetrain.drive_for(FORWARD, Step_MM, MM)\n    # Right\n    elif right_move:\n        drivetrain.turn_for(RIGHT, 90, DEGREES)\n        drivetrain.drive_for(FORWARD, Step_MM, MM)\n    # Backward\n    else:\n        drivetrain.turn_for(RIGHT, 180, DEGREES)\n\n    row, col = get_cell()\n    Visited[row + Offset][col + Offset] = True\n    Path.append((row, col))\n\n# get the location of each move as coordinates\n\ndef get_cell():\n    x = location.position(X, MM)\n    y = location.position(Y, MM)\n\n    col = round(x / Grid_Size)\n    row = round(y / Grid_Size)\n\n    return row, col\n\n# BFS to find the quickest route of the maze\ndef BFS(Start, End):\n    from collections import deque\n\n    queue = deque([Start])\n    Came_From = {Start: None}\n\n    while queue:\n        Current = queue.popleft()\n\n        if Current == End:\n            break\n        row, col = Current\n\n        Next_Squares = []\n        for i in range(len(Path) - 1):\n             if Path[i] == Current:\n                 Next_Squares.append(Path[i+1])\n             if Path[i+1] == Current:\n                Next_Squares.append(Path[i])\n\n        for Next_row, Next_col in Next_Squares:\n            Grid_row = Next_row + Offset\n            Grid_col = Next_col + Offset\n\n            if Grid_row < 0 or Grid_row >= Size or Grid_col < 0 or Grid_col >= Size:\n                continue\n\n            if Visited[Grid_row][Grid_col] and (Next_row, Next_col) not in Came_From:\n                queue.append((Next_row, Next_col))\n                Came_From[(Next_row, Next_col)] = Current\n\n    Shortest_Path = []\n    Step = End\n\n    while Step is not None:\n        Shortest_Path.append(Step)\n        Step = Came_From.get(Step)\n\n    Shortest_Path.reverse()\n    return Shortest_Path\n\n#return home function using the quickest route\n\ndef Follow_Path(Shortest_Path):\n    for i in range(len(Shortest_Path) - 1):\n\n        Current_row, Current_col = Shortest_Path[i]\n        Next_row, Next_col = Shortest_Path[i + 1]\n\n        Row_Diff = Next_row - Current_row\n        Col_Diff = Next_col - Current_col\n\n         # north\n        if Row_Diff == -1:\n            drivetrain.turn_to_heading(90, DEGREES)\n\n        # south\n        elif Row_Diff == 1:\n            drivetrain.turn_to_heading(270, DEGREES)\n\n        # west\n        elif Col_Diff == -1:\n            drivetrain.turn_to_heading(180, DEGREES)\n\n        # east\n        elif Col_Diff == 1:\n            drivetrain.turn_to_heading(0, DEGREES)\n\n        drivetrain.drive_for(FORWARD, Step_MM, MM)\n\n\nvr_thread(main)\n\n\n     \n\n\n    \n\n\n\n","textLanguage":"python","robotConfig":[],"slot":0,"platform":"PG","sdkVersion":"20240802.15.00.00","appVersion":"4.63.0","minVersion":"4.60.0","fileFormat":"2.0.0","targetBrainGen":"First","v5SoundsEnabled":false,"aiVisionSettings":{"colors":[],"codes":[],"tags":true,"AIObjects":true,"AIObjectModel":[],"aiModelDropDownValue":null},"playground":"DynamicWallMaze","robotModel":"vr"}